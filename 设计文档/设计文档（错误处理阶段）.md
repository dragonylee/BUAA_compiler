# 编译器设计文档

<p align="right">18373114 李英龙</p>

<br>

## 总规

### 文法定义

```
<加法运算符> ::= +|-
<乘法运算符> ::= *|/ 
<关系运算符> ::= <|<=|>|>=|!=|== 
<字母> ::= _|a|...|z|A|...|Z
<数字> ::= 0|1|...|9
<字符> ::= '<加法运算符>'|'<乘法运算符>'|'<字母>'|'<数字>'
<字符串> ::= "{十进制编码为32,33,35-126的ASCII字符}"
<程序> ::= [<常量说明>][<变量说明>]{<有返回值函数定义>|<无返回值函数定义>}<主函数>
<常量说明> ::= const<常量定义>;{const<常量定义>;}
<常量定义> ::= int<标识符>＝<整数>{,<标识符>＝<整数>}|char<标识符>＝<字符>{,<标识符>＝<字符>}
<无符号整数> ::= <数字>{<数字>}
<整数> ::= [+|-]<无符号整数>
<标识符> ::= <字母>{<字母>|<数字>}
<声明头部> ::= int<标识符>|char<标识符>
<常量> ::= <整数>|<字符>
<变量说明> ::= <变量定义>;{<变量定义>;}
<变量定义> ::= <变量定义无初始化>|<变量定义及初始化>
<变量定义无初始化> ::= <类型标识符>(<标识符>|<标识符>'['<无符号整数>']'|<标识符>'['<无符号整数>']''['<无符号整数>']'){,(<标识符>|<标识符>'['<无符号整数>']'|<标识符>'['<无符号整数>']''['<无符号整数>']')}
<变量定义及初始化> ::= <类型标识符><标识符>=<常量>|<类型标识符><标识符>'['<无符号整数>']'='{'<常量>{,<常量>}'}'|<类型标识符><标识符>'['<无符号整数>']''['<无符号整数>']'='{''{'<常量>{,<常量>}'}'{,'{'<常量>{,<常量>}'}'}'}'
<类型标识符> ::= int|char
<有返回值函数定义> ::= <声明头部>'('<参数表>')' '{'<复合语句>'}'
<无返回值函数定义> ::= void<标识符>'('<参数表>')''{'<复合语句>'}'
<复合语句> ::=[<常量说明>][<变量说明>]<语句列>
<参数表> ::= <类型标识符><标识符>{,<类型标识符><标识符>} | <空>
<主函数> ::= void main'('')' '{'<复合语句>'}'
<表达式> ::= [+|-]<项>{<加法运算符><项>}
<项> ::= <因子>{<乘法运算符><因子>}
<因子> ::= <标识符>|<标识符>'['<表达式>']'|<标识符>'['<表达式>']''['<表达式>']'|'('<表达式>')'|<整数>|<字符>|<有返回值函数调用语句>
<语句> ::= <循环语句>|<条件语句>|<有返回值函数调用语句>;|<无返回值函数调用语句>;|<赋值语句>;|<读语句>;|<写语句>;|<情况语句>|<空>;|<返回语句>;|'{'<语句列>'}'
<赋值语句> ::= <标识符>＝<表达式>|<标识符>'['<表达式>']'=<表达式>|<标识符>'['<表达式>']''['<表达式>']'=<表达式>
<条件语句> ::= if '('<条件>')'<语句>［else<语句>］
<条件> ::= <表达式><关系运算符><表达式>
<循环语句> ::= while'('<条件>')'<语句>| for'('<标识符>＝<表达式>;<条件>;<标识符>＝<标识符>(+|-)<步长>')'<语句>
<步长> ::= <无符号整数>
<情况语句> ::= switch '('<表达式>')' '{'<情况表><缺省>'}'
<情况表> ::= <情况子语句>{<情况子语句>}
<情况子语句> ::= case<常量>:<语句>
<缺省> ::= default:<语句>
<有返回值函数调用语句> ::= <标识符>'('<值参数表>')'
<无返回值函数调用语句> ::= <标识符>'('<值参数表>')'
<值参数表> ::= <表达式>{,<表达式>}|<空>
<语句列> ::= {<语句>}
<读语句> ::= scanf '('<标识符>')'
<写语句> ::= printf'('<字符串>,<表达式>')'| printf'('<字符串>')'| printf'('<表达式>')'
<返回语句> ::= return['('<表达式>')']
```



<br>

## 词法分析

<br>

### 总体规划

设计一个词法分析器，要求根据单词类别码的统一规定，对输入程序进行词法分析，然后输出每一个单词（token）对应的**类别码**以及**值**。实现方式为有限状态自动机，根据每个字符的输入来实现状态的转移，在实际实现过程中，可以简化自动机的操作以提高效率，这将在后面详细讲述。

除此之外，在词法分析阶段中，还应该记录每个 token 的行数；遇到状态机不能处理的字符串，也就是说遇到了错误，还应该进行错误处理（这一次作业给出的源程序都是正确的，但是最好也预留出错误处理的接口，方便以后扩展）；另外每一个 token 都应该保存起来，以供后续阶段使用。

定义结构体 token，里面有三个属性：类别码、值、行数。

实现一个函数 `int get_token(token &nowtoken)` ，每次调用这个函数，就写入下一个 token 到 `nowtoken` 之中，并且返回这个 token 的类别码，如果到文件末尾则返回 -1 。

<br>

### 类别码定义

对于每个类别码，宏定义一个整型数与之对应，这样只用存储一个 int 类型（而不是一个字符串），然后再实现一个类别码到其名称的转换函数，方便进行输出。

| 类别码    | 值       | 说明                           |
| --------- | -------- | ------------------------------ |
| IDENFR    | 标识符   | \<letter>{\<letter>\|\<digit>} |
| INTCON    | 整型常量 |                                |
| CHARCON   | 字符常量 | 只能是letter、digit、加减乘除  |
| STRCON    | 字符串   | 不能为空                       |
| CONSTTK   | const    |                                |
| INTTK     | int      | 带有TK的就是保留字             |
| CHARTK    | char     |                                |
| VOIDTK    | void     |                                |
| MAINTK    | main     |                                |
| IFTK      | if       |                                |
| ELSETK    | else     |                                |
| SWITCHTK  | switch   |                                |
| CASETK    | case     |                                |
| DEFAULTTK | default  |                                |
| WHILETK   | while    |                                |
| FORTK     | for      |                                |
| SCANFTK   | scanf    |                                |
| PRINTFTK  | printf   |                                |
| RETURNTK  | return   |                                |
| PLUS      | +        |                                |
| MINU      | -        |                                |
| MULT      | *        |                                |
| DIV       | /        |                                |
| LSS       | <        |                                |
| LEQ       | <=       |                                |
| GRE       | >        |                                |
| GEQ       | \>=      |                                |
| EQL       | ==       |                                |
| NEQ       | !=       |                                |
| COLON     | :        |                                |
| ASSIGN    | =        |                                |
| SEMICN    | ;        |                                |
| COMMA     | ,        |                                |
| LPARENT   | (        |                                |
| RPARENT   | )        |                                |
| LBRACK    | [        |                                |
| RBRACK    | ]        |                                |
| LBRACE    | {        |                                |
| RBRACE    | }        |                                |

具体哪个标识符对应哪个整数并不重要，只要保证一一对应就行了。

<br>

### get_token(token &) 函数实现

每次调用 `get_token(token &nowtoken)` 时，首先跳过空白字符，并在这个过程中如果遇到换行符则让当前行数加一。然后，根据每个 token 的第一个字符，有如下若干种情况：

- 字符值为 -1，也就是到了文件末尾，return -1；
- 首字符为 letter（包括所有字母以及下划线）：可能是一个标识符或者保留字，往后读完所有连续的 letter 和 digit，然后判断是否为保留字，并根据判断结果处理后返回；
- 首字符为 digit（'0'-'9'）：可能是整型常量，往后读完所有连续的 digit，然后处理后返回；
- 首字符为单引号（'\\''）：可能是字符常量，往后读两位，判断是否合法，然后处理后返回；
- 首字符为双引号（'\\"'）：可能是字符串常量，往后读到下一个双引号，判断字符串长度是否为 0，以及里面的字符是否合法，然后处理后返回；
- 首字符为特殊字符（这里的特殊字符指的是，仅凭一个符号就可以唯一标识，包括加、减、乘、除、冒号、分号、逗号、六个括号）：直接处理后返回；
- 首字符为小于号（'<'）：可能是小于或者小于等于，往后读进行判断，然后处理后返回；
- 首字符为大于号（'<'）：可能是大于或者大于等于，往后读进行判断，然后处理后返回；
- 首字符为感叹号（'!'）：可能是不等于，往后读一位，判断是否合法，然后处理后返回；
- 首字符为等于号（'='）：可能是赋值或者双等号，往后读进行判断，然后处理后返回；
- 其它情况：报错，return 0；

这应该覆盖了所有可能的合法的单词情况，在原来自动机的基础上做了简化，更加易于实现。

<br>

### 结果输出

根据输入文件，不停调用 `get_token()` 一直到文件末尾，然后每次调用后输出相应的内容即可。

<br>

<br>

## 语法分析

<br>

### 总体设计

语法分析的目标是基于之前的词法分析结果（也就是token序列），按照文法规则，用递归下降分析法识别出所有的语法成分。这里涉及到区分哪些是语法、哪些是单词，也就是区分终结符和非终结符。在我的语法分析程序中，非终结符是文法定义左边的所有语法成分除去`<字母>、<数字>` ，而终结符就是token的所有类别码。

根据递归下降法的规则，对于每个语法成分都要写一个子程序来识别这个语法成分，所以最终程序总共有 43 个子程序去识别不同的语法成分，而识别入口是 `chengxu()`（为了方便，所有子程序的命名都是该语法成分的拼音）。除此之外进行约定：

- 每个子程序都要留出识别错误的接口；
- 在进入子程序之前，预先读入一个token；在完成子程序之后，读入一个token为下一个做准备；
- 由于要进行语法成分输出，每个子函数的语法成分输出都要放到最后，并且留出开关控制是否输出；

原本的文法满足不存在左递归的要求，但是不满足首符号集不相交的规则，本来应该按照提取左公因子来修改文法，但是这样有点麻烦（因为可能要增加语法成分），所以我的做法是预先取出后面的token进行判断，来决定应该选择哪个选项。

然后就是根据每个语法成分的特点，进行处理。

<br>

### 子程序实现

有一些子程序对应的语法成分直接解析成终结符，还有一些没有选择直接识别和递归，这里只挑一些各个选择的首符号集有交集的复杂的语法成分来进行说明：

##### <程序>

```
<程序> ::= [<常量说明>][<变量说明>]{<有返回值函数定义>|<无返回值函数定义>}<主函数>
```

先分析每个选择的首符号集：

- <常量说明>的首符号集是{CONSTTK}
- <变量说明>的首符号集是{INTTK,CHARTK}
- <有返回值函数定义>的首符号集是{INTTK,CHARTK}
- <无返回值函数定义>的首符号集是{VOIDTK}
- <主函数>的首符号集是{VOIDTK}

可以看出其中有些有交集，所以处理步骤如下：

- 如果当前token的type是CONSTTK，进入<常量说明>；
- 如果当前是{INTTK,CHARTK}，且后两个的token的type不是LPARENT，进入<变量说明>；
- 下面的可能重复若干次：
  - 如果当前是{INTTK,CHARTK}，且后两个的token的type是LPARENT，进入<有返回值函数定义>；
  - 如果当前是VOIDTK，且后一个的token的type不是MAINTK，进入<无返回值函数定义>；
- 进入主函数；

##### <变量说明>

```
<变量说明> ::= <变量定义>;{<变量定义>;}
```

本身这个没什么复杂的，也没有选择，但是因为在 <程序> 中，变量说明后面可能是有返回值函数定义，所以在进入 <变量定义> 之前，还需要确定后两个的token的type不是LPARENT。

##### <变量定义>

```
<变量定义> ::= <变量定义无初始化>|<变量定义及初始化>
```

这两个选择的首符号集都一样，甚至往后面很多都可能是一样的，所以处理方式如下：

如果以下三个条件：

- tokens[cur+1]为ASSIGN
- tokens[cur+1]为LBRACK 且 tokens[cur+4]为ASSIGN
- tokens[cur+1]为LBRACK 且 tokens[cur+4]为LBRACK 且 token[cur+7]为ASSIGN

至少有一个为真，那么进入<变量定义及初始化>；

否则进入<变量定义无初始化>。

##### <复合语句>

```
<复合语句> ::=[<常量说明>][<变量说明>]<语句列>
```

乍一看跟<程序>很像，有很多选项，但是其实仔细分析就会发现，三个候选语法成分的首符号集不相交，所以直接根据当前token的类别码来选择即可。

##### <因子>

```
<因子> ::= <标识符>|<标识符>'['<表达式>']'|<标识符>'['<表达式>']''['<表达式>']'|'('<表达式>')'|<整数>|<字符>|<有返回值函数调用语句>
```

有点复杂，处理过程如下：

- 如果nowtoken的type是IDENFR，
  - 如果下一个token的type是LBRACK，进入表达式，出来后识别一个RBRACK，
    - 如果下一个token的type还是LBRACK，那么就按照二维数组处理；
    - 如果不是，那么就是一维数组；
  - 如果不是，那么就只识别一个标识符；
- 如果nowtoken的type是IDENFR，且tokens[cur].type==LPARENT，那么进入<有返回值函数调用语句>；
- 如果nowtoken的type是LPARENT，进入<表达式>，然后处理RPARENT；
- 如果nowtoken的type是PLUS、MINU或INTCON，进入<整数>；
- 如果nowtoken的type是CHARCON，进入<字符>；

##### <语句>

```
<语句> ::= <循环语句>|<条件语句>|<有返回值函数调用语句>;|<无返回值函数调用语句>;|<赋值语句>;|<读语句>;|<写语句>;|<情况语句>|<空>;|<返回语句>;|'{'<语句列>'}'
```

总共有如下若干种可能的选择：

| 语法成分                | 首符号集      |
| ----------------------- | ------------- |
| <循环语句>              | WHILETK,FORTK |
| <条件语句>              | IFTK          |
| <有返回值函数调用语句>; | IDENFR        |
| <无返回值函数调用语句>; | IDENFR        |
| <赋值语句>;             | IDENFR        |
| <读语句>;               | SCANFTK       |
| <写语句>;               | PRINTFTK      |
| <情况语句>              | SWITCHTK      |
| <空>;                   | SEMICN        |
| <返回语句>;             | RETURNTK      |
| '{'<语句列>'}'          | LBRACE        |

其中只有三个的首符号集是有交集的，他们是`<有返回值函数调用语句>;
<无返回值函数调用语句>;
<赋值语句>;`，赋值语句的下一个token的类型是 ASSIGN或LBRACK，函数调用语句的下一个token的类型是LPARENT，可以先区分开，然后发现有返回值函数调用语句和无返回值函数调用语句的文法居然是一模一样的，所以这里我们在处理语法的时候就不得不建立一个**符号表**了，有关符号表的处理见后面详述。

##### <语句列>

```
<语句列> ::= {<语句>}
```

<语句>的首符号集为{WHILETK,FORTK,IDENFR,SCANFTK,PRINTFTK,SWITCHTK,SEMICN,RETURNTK,LBRACE,IFTK}，所以出现这些的时候进入<语句>即可。

<br>

### 结果输出

实验作业要求输出每个token的类别，并且在识别成功语法成分的时候，输出对应语法成分的名称。并且保证输入程序都是正确的。

这里由于约定了每个子程序的语法成分输出都留到最后进行，那就说明在每个子程序内部（因为要读入一个token为下面做准备之后才能结束程序），进行语法成分输出时已经读了下一个token了，所以只需在读token的函数的最前面把当前的token输出，就能够满足要求。

另外所有的输出都是用调用函数来实现，而那个函数只有在宏定义了某个东西的时候才会执行，这就保证了开关的效果。

<br>

<br>

## 符号表

符号表存储的信息有：

- 标识符名字（word）；
- 标识符的属性（objtype），包括 CONST, VARIABLE, ARRAY, FUNCTION；
- 标识符的类型（vartype），包括 INT, CHAR, STRING, VOID；
- 符号表的维数，这里对于数组记录维数，对于函数记录参数个数，对于其它记为0；
- 地址（addr），内存中分配的地址，现阶段不用考虑这个；
- 是否有返回值（is_ret），记录函数是否有返回值；
- 参数列表（parameters），记录函数的各个参数的类别；

根据文法的定义，所有的变量说明以及常量说明都会在全局或者函数定义的开头给出，也就是说整个程序只会有两种类型的标识符：全局的和局部的。其中全局符号表只有一张，局部符号表每个函数（包括main）各对应一张，所以可以用 `map<string, symbolEntry>` 结构来定义符号表（symbolEntry是每个符号表项），然后全局定义一张全局符号表，局部符号表再用一个map结构来定义。

把每一种对符号表的操作（插入、修改、读取等等）定义一个函数来实现，就可以完成符号表的操作了。

<br>

<br>

## 错误处理

本次作业给出的可能的错误项总共有如下若干种：

```cpp
#define error_a 'a' // 非法符号或不符合词法
#define error_b 'b' // 名字重定义
#define error_c 'c' // 未定义的名字
#define error_d 'd' // 函数参数个数不匹配
#define error_e 'e' // 函数参数类型不匹配
#define error_f 'f' // 条件判断中出现不合法的类型
#define error_g 'g' // 无返回值的函数存在不匹配的return语句
#define error_h 'h' // 有返回值的函数缺少return语句或存在不匹配的return语句
#define error_i 'i' // 数组元素的下标只能是整型表达式
#define error_j 'j' // 不能改变常量的值
#define error_k 'k' // 行末应为分号
#define error_l 'l' // 应为右小括号’)’
#define error_m 'm' // 应为右中括号’]’
#define error_n 'n' // 数组初始化个数不匹配
#define error_o 'o' // switch <常量>类型不一致
#define error_p 'p' // switch 缺少缺省语句
```

要求需要识别错误的代码，输出出错行数以及错误代码。

其中很多错误是通过检查当前的token类型，或者稍微查询一下符号表就可以解决的，比如说名字重定义、行末应为分号等等，然后函数参数相关的错误因为在符号表项中定义了参数信息，所以也很好解决，现在只讨论几个比较困难的点以及需要注意的地方：

- 关于表达式类型判别：数组下标错误、<常量>类型判断等等错误判断，都需要识别表达式的类型（INT还是CHAR），所以有关表达式的三个语法分析子程序需要稍作修改，用递归的方式判断表达式类型。我使用的是返回值的方式。
- 行数输出问题：对于有一些错误，比如行末应为分号，由于当前判断错误的时候用的是nowtoken，而如果行末没有分号的话，这个nowtoken就应该是下一个单词，而下一个单词的行数不一定就是当前行了，所以错误行数输出的时候，应该输出上一个token的行数。
- 遇到错误如何处理：有些错误（比如未定义的名字）应当照常get_nowtoken()（相当于跳过当前单词），而有些错误（比如行末应为分号）应当啥也不做（避免跳过下一个单词），有些错误甚至应当一直读到期望单词为止。
- 变量重定义问题：有些函数定义的时候如果名字和全局变量重了，简单的跳过当前单词肯定不行（这样会导致后面一堆错误，因为没有记录函数信息），所以我采用的方式是覆盖，如果出现变量重定义，就用新的去覆盖旧的。

除此之外，照常要设置错误输出开关以及最大输出行数，方便后续扩展。

<br>

<br>

## 中间代码

定义中间代码格式（操作数3一般用来保存结果）：

| 操作符   | 操作数1 | 操作数2 | 操作数3 | 说明                                   |
| -------- | ------- | ------- | ------- | -------------------------------------- |
| ADD      | t1      | t2      | t3      | t1 = t2 + t3                           |
| SUB      | t1      | t2      | t3      | t1 = t2 - t3                           |
| MULT     | t1      | t2      | t3      | t1 = t2 * t3                           |
| DIV      | t1      | t2      | t3      | t1 = t2 / t3                           |
| LARRAY   | t1      | t2      | t3      | t1 = t2[t3]                            |
| SARRAY   | t1      | t2      | t3      | t2[t3] = t1                            |
| ASSIGN   | t1      | t2      |         | t1 = t2                                |
| BEQ      | t1      | t2      | t3      | t1 == t2 -> jump to t3                 |
| BNE      | t1      | t2      | t3      | t1 != t2 -> jump to t3                 |
| BLE      | t1      | t2      | t3      | t1 <= t2 -> jump to t3                 |
| BLT      | t1      | t2      | t3      | t1 < t2 -> jump to t3                  |
| JUMP     | t1      |         |         | jump to t1(label)                      |
| SETLABEL | t1      |         |         | set label named t1                     |
| RETURN   |         |         |         | return                                 |
| SENDP    | t1      | t2      | t3      | send value t1 to t2(t3) (t2 is offset) |
| CALL     | t1      |         |         | jump to t1(func name)                  |
| PUSH     |         |         |         | push used r                            |
| POP      |         |         |         | pop used r                             |
| READ     | t1      | t2      |         | read t1 typed t2                       |
| PRINT    | t1      | t2      | t3      | print t1 typed t2 (label t3)           |
| PARA     | t1      | t2      | t3      | parameter t1 typed t2 offset t3        |
| SETSTR   | t1      |         |         | just output t1                         |
| EXIT     |         |         |         | exit                                   |

