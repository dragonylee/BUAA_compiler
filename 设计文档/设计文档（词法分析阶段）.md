# 编译器设计文档

<p align="right">18373114 李英龙</p>





## 词法分析

<br>

### 总体规划

设计一个词法分析器，要求根据单词类别码的统一规定，对输入程序进行词法分析，然后输出每一个单词（token）对应的**类别码**以及**值**。实现方式为有限状态自动机，根据每个字符的输入来实现状态的转移，在实际实现过程中，可以简化自动机的操作以提高效率，这将在后面详细讲述。

除此之外，在词法分析阶段中，还应该记录每个 token 的行数；遇到状态机不能处理的字符串，也就是说遇到了错误，还应该进行错误处理（这一次作业给出的源程序都是正确的，但是最好也预留出错误处理的接口，方便以后扩展）；另外每一个 token 都应该保存起来，以供后续阶段使用。

定义结构体 token，里面有三个属性：类别码、值、行数。

实现一个函数 `int get_token(token &nowtoken)` ，每次调用这个函数，就写入下一个 token 到 `nowtoken` 之中，并且返回这个 token 的类别码，如果到文件末尾则返回 -1 。

<br>

### 类别码定义

对于每个类别码，宏定义一个整型数与之对应，这样只用存储一个 int 类型（而不是一个字符串），然后再实现一个类别码到其名称的转换函数，方便进行输出。

| 类别码    | 值       | 说明                           |
| --------- | -------- | ------------------------------ |
| IDENFR    | 标识符   | \<letter>{\<letter>\|\<digit>} |
| INTCON    | 整型常量 |                                |
| CHARCON   | 字符常量 | 只能是letter、digit、加减乘除  |
| STRCON    | 字符串   | 不能为空                       |
| CONSTTK   | const    |                                |
| INTTK     | int      | 带有TK的就是保留字             |
| CHARTK    | char     |                                |
| VOIDTK    | void     |                                |
| MAINTK    | main     |                                |
| IFTK      | if       |                                |
| ELSETK    | else     |                                |
| SWITCHTK  | switch   |                                |
| CASETK    | case     |                                |
| DEFAULTTK | default  |                                |
| WHILETK   | while    |                                |
| FORTK     | for      |                                |
| SCANFTK   | scanf    |                                |
| PRINTFTK  | printf   |                                |
| RETURNTK  | return   |                                |
| PLUS      | +        |                                |
| MINU      | -        |                                |
| MULT      | *        |                                |
| DIV       | /        |                                |
| LSS       | <        |                                |
| LEQ       | <=       |                                |
| GRE       | >        |                                |
| GEQ       | \>=      |                                |
| EQL       | ==       |                                |
| NEQ       | !=       |                                |
| COLON     | :        |                                |
| ASSIGN    | =        |                                |
| SEMICN    | ;        |                                |
| COMMA     | ,        |                                |
| LPARENT   | (        |                                |
| RPARENT   | )        |                                |
| LBRACK    | [        |                                |
| RBRACK    | ]        |                                |
| LBRACE    | {        |                                |
| RBRACE    | }        |                                |

具体哪个标识符对应哪个整数并不重要，只要保证一一对应就行了。

<br>

### get_token(token &) 函数实现

每次调用 `get_token(token &nowtoken)` 时，首先跳过空白字符，并在这个过程中如果遇到换行符则让当前行数加一。然后，根据每个 token 的第一个字符，有如下若干种情况：

- 字符值为 -1，也就是到了文件末尾，return -1；
- 首字符为 letter（包括所有字母以及下划线）：可能是一个标识符或者保留字，往后读完所有连续的 letter 和 digit，然后判断是否为保留字，并根据判断结果处理后返回；
- 首字符为 digit（'0'-'9'）：可能是整型常量，往后读完所有连续的 digit，然后处理后返回；
- 首字符为单引号（'\\''）：可能是字符常量，往后读两位，判断是否合法，然后处理后返回；
- 首字符为双引号（'\\"'）：可能是字符串常量，往后读到下一个双引号，判断字符串长度是否为 0，以及里面的字符是否合法，然后处理后返回；
- 首字符为特殊字符（这里的特殊字符指的是，仅凭一个符号就可以唯一标识，包括加、减、乘、除、冒号、分号、逗号、六个括号）：直接处理后返回；
- 首字符为小于号（'<'）：可能是小于或者小于等于，往后读进行判断，然后处理后返回；
- 首字符为大于号（'<'）：可能是大于或者大于等于，往后读进行判断，然后处理后返回；
- 首字符为感叹号（'!'）：可能是不等于，往后读一位，判断是否合法，然后处理后返回；
- 首字符为等于号（'='）：可能是赋值或者双等号，往后读进行判断，然后处理后返回；
- 其它情况：报错，return 0；

这应该覆盖了所有可能的合法的单词情况，在原来自动机的基础上做了简化，更加易于实现。

<br>

### 结果输出

根据输入文件，不停调用 `get_token()` 一直到文件末尾，然后每次调用后输出相应的内容即可。